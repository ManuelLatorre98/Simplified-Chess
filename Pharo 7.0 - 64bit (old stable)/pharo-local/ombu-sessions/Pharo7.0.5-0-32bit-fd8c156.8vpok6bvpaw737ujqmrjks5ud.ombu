OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:13:46.873869-03:00' ],		#prior : OmReference [ 'Pharo7.0.5-0-32bit-fd8c156.bpwqoxqu85yimuvhul5wrqgv8', '6' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j.\rc setColumnaEscaque: i.\rorigin:= self innerBounds origin.\rself addMorph: c.\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin.\r^c.',			#stamp : 'ManuelLatorre 7/31/2019 15:24',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j.\rc setColumnaEscaque: i.\rorigin:= self innerBounds origin.\r"self addMorph: c."\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin.\r^c.',			#stamp : 'Manu 11/11/2020 12:13',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:14:48.199869-03:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j.\rc setColumnaEscaque: i.\rorigin:= self innerBounds origin.\r"self addMorph: c."\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin.\r^c.',			#stamp : 'Manu 11/11/2020 12:13',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j.\rc setColumnaEscaque: i.\rorigin:= self innerBounds origin.\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin."Ubico el escaque"\r^c.',			#stamp : 'Manu 11/11/2020 12:14',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:23:09.813869-03:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j.\rc setColumnaEscaque: i.\rorigin:= self innerBounds origin.\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin."Ubico el escaque"\r^c.',			#stamp : 'Manu 11/11/2020 12:14',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j.""\rc setColumnaEscaque: i.\rorigin:= self innerBounds origin.\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin."Utilizo las fila y columna de la matriz (i,j) como referencia para ubicar el escaque "\r^c.',			#stamp : 'Manu 11/11/2020 12:23',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:23:34.243869-03:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j.""\rc setColumnaEscaque: i.\rorigin:= self innerBounds origin.\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin."Utilizo las fila y columna de la matriz (i,j) como referencia para ubicar el escaque "\r^c.',			#stamp : 'Manu 11/11/2020 12:23',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j."Guardo a que columna pertenece"\rc setColumnaEscaque: i."Guardo a que fila pertenece"\rorigin:= self innerBounds origin.\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin."Utilizo las fila y columna de la matriz (i,j) como referencia para ubicar el escaque "\r^c.',			#stamp : 'Manu 11/11/2020 12:23',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:23:41.554869-03:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j."Guardo a que columna pertenece"\rc setColumnaEscaque: i."Guardo a que fila pertenece"\rorigin:= self innerBounds origin.\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin."Utilizo las fila y columna de la matriz (i,j) como referencia para ubicar el escaque "\r^c.',			#stamp : 'Manu 11/11/2020 12:23',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j."Guardo a que columna pertenece de la matriz"\rc setColumnaEscaque: i."Guardo a que fila pertenece matriz"\rorigin:= self innerBounds origin.\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin."Utilizo las fila y columna de la matriz (i,j) como referencia para ubicar el escaque "\r^c.',			#stamp : 'Manu 11/11/2020 12:23',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:25:28.149869-03:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ].\rself position: 0@20. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/10/2020 13:52',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 0@30. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:25',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:25:39.850869-03:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 0@30. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:25',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 0@100. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:25',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:25:53.212869-03:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 0@100. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:25',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 0@20. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:25',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:29:47.483869-03:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j."Guardo a que columna pertenece de la matriz"\rc setColumnaEscaque: i."Guardo a que fila pertenece matriz"\rorigin:= self innerBounds origin.\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin."Utilizo las fila y columna de la matriz (i,j) como referencia para ubicar el escaque "\r^c.',			#stamp : 'Manu 11/11/2020 12:23',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j."Guardo a que columna pertenece de la matriz"\rc setColumnaEscaque: i."Guardo a que fila pertenece matriz"\r"origin:= self innerBounds origin." "Lo utilizo para que los escaques se mantengan dentro del borderedMorph"\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )"+ origin"."Utilizo las fila y columna de la matriz (i,j) como referencia para ubicar el escaque en pantalla, junto con sus dimensiones (width height)"\r^c."Retorno el nuevo escaque para guardarlo en la matriz"',			#stamp : 'Manu 11/11/2020 12:29',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:30:03.774869-03:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 0@20. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:25',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 100@20. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:30',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:30:26.378869-03:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 100@20. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:30',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 100@100. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:30',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:30:40.402869-03:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 100@100. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:30',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 0@20. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:30',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:30:59.200869-03:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j."Guardo a que columna pertenece de la matriz"\rc setColumnaEscaque: i."Guardo a que fila pertenece matriz"\r"origin:= self innerBounds origin." "Lo utilizo para que los escaques se mantengan dentro del borderedMorph"\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )"+ origin"."Utilizo las fila y columna de la matriz (i,j) como referencia para ubicar el escaque en pantalla, junto con sus dimensiones (width height)"\r^c."Retorno el nuevo escaque para guardarlo en la matriz"',			#stamp : 'Manu 11/11/2020 12:29',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j."Guardo a que columna pertenece de la matriz"\rc setColumnaEscaque: i."Guardo a que fila pertenece matriz"\rorigin:= self innerBounds origin. "Lo utilizo para que los escaques se mantengan dentro del borderedMorph"\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin."Utilizo las fila y columna de la matriz (i,j) como referencia para ubicar el escaque en pantalla, junto con sus dimensiones (width height)"\r^c."Retorno el nuevo escaque para guardarlo en la matriz"',			#stamp : 'Manu 11/11/2020 12:30',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:32:22.040869-03:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j."Guardo a que columna pertenece de la matriz"\rc setColumnaEscaque: i."Guardo a que fila pertenece matriz"\rorigin:= self innerBounds origin. "Lo utilizo para que los escaques se mantengan dentro del borderedMorph"\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin."Utilizo las fila y columna de la matriz (i,j) como referencia para ubicar el escaque en pantalla, junto con sus dimensiones (width height)"\r^c."Retorno el nuevo escaque para guardarlo en la matriz"',			#stamp : 'Manu 11/11/2020 12:30',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #'newCellAt:at:',			#protocol : #'instance creation',			#sourceCode : 'newCellAt: i at:j \r|c origin|\rc:= Escaque new.\rc setFilaEscaque: j."Guardo a que columna pertenece de la matriz"\rc setColumnaEscaque: i."Guardo a que fila pertenece matriz"\rorigin:= self innerBounds origin. "Lo utilizo para que los escaques se mantengan siempre dentro del borderedMorph"\rself addMorph: c."Muestro el escaque"\rc position: ((i-1)*c width) @ ((j-1)*c height )+ origin."Utilizo las fila y columna de la matriz (i,j) como referencia para ubicar el escaque en pantalla, junto con sus dimensiones (width height)"\r^c."Retorno el nuevo escaque para guardarlo en la matriz"',			#stamp : 'Manu 11/11/2020 12:32',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:34:40.982869-03:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del morph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 0@20. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:30',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r| muestraEscaque ancho alto n|\rsuper initialize. "SuperClase BorderedMorph"\rn := self cellsPerSide. "Cantidad de escaques FilaxColumna"\rmuestraEscaque := Escaque new.\rancho:= muestraEscaque width. "ancho de escaque"\ralto:= muestraEscaque height. "alto de escaque"\rself bounds: (5@5 extent: ((ancho*n) @(alto*n))+ (2 * self borderWidth))."seteo medidas del BorderedMorph y ancho linea del borde"\rcolEscaques:= Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]."La matriz es para tener referencia de los escaques y poder trabajar SOBRE ellos, cuando se crea el escaque hago que se muestre desde ahi"\rself position: 0@20. "ubico el tablero donde quiero"\rself casillasOscuras.\rself bordes.',			#stamp : 'Manu 11/11/2020 12:34',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:37:20.959869-03:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #casillasOscuras,			#protocol : #'as yet unclassified',			#sourceCode : 'casillasOscuras\r1 to: 8 do:[:fil| 1 to:8 do:[:col|\r\t\t(((fil%2)>0) & (col%2=0))ifTrue:[ \r\t\t\t(colEscaques at:fil at:col) color: Color brown.].\r\t\t\r\t\t(((fil%2)=0) & (col%2>0))ifTrue:[ \r\t\t\t(colEscaques at:fil at:col) color: Color brown.]\r\t\t]]\r',			#stamp : 'ManuelLatorre 7/31/2019 15:33',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #casillasOscuras,			#protocol : #'as yet unclassified',			#sourceCode : 'casillasOscuras\r1 to: 8 do:[:fil| 1 to:8 do:[:col|\r\t\t(((fil%2)>0) & (col%2=0))ifTrue:[ \r\t\t\t(colEscaques at:fil at:col) color: Color black.].\r\t\t\r\t\t(((fil%2)=0) & (col%2>0))ifTrue:[ \r\t\t\t(colEscaques at:fil at:col) color: Color black.]\r\t\t]]\r',			#stamp : 'Manu 11/11/2020 12:37',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T12:37:42.898869-03:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #casillasOscuras,			#protocol : #'as yet unclassified',			#sourceCode : 'casillasOscuras\r1 to: 8 do:[:fil| 1 to:8 do:[:col|\r\t\t(((fil%2)>0) & (col%2=0))ifTrue:[ \r\t\t\t(colEscaques at:fil at:col) color: Color black.].\r\t\t\r\t\t(((fil%2)=0) & (col%2>0))ifTrue:[ \r\t\t\t(colEscaques at:fil at:col) color: Color black.]\r\t\t]]\r',			#stamp : 'Manu 11/11/2020 12:37',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Tablero			},			#name : #casillasOscuras,			#protocol : #'as yet unclassified',			#sourceCode : 'casillasOscuras\r1 to: 8 do:[:fil| 1 to:8 do:[:col|\r\t\t(((fil%2)>0) & (col%2=0))ifTrue:[ \r\t\t\t(colEscaques at:fil at:col) color: Color brown.].\r\t\t\r\t\t(((fil%2)=0) & (col%2>0))ifTrue:[ \r\t\t\t(colEscaques at:fil at:col) color: Color brown.]\r\t\t]]\r',			#stamp : 'Manu 11/11/2020 12:37',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:08:11.648869-03:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ].\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ].\r\r\t\r\t(columnaPieza =1)ifTrue: [ \r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ \r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'ManuelLatorre 8/18/2019 15:19',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ \r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ \r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:08',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:13:33.851869-03:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ \r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ \r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:08',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ \r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:13',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:13:41.700869-03:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ \r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:13',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ \r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:13',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:15:43.112869-03:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ \r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:13',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ \r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:15',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:15:47.500869-03:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ \r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:15',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ \r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:15',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:15:59.831869-03:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ \r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:15',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ "si llego al final no puede comer"\r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:15',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:18:44.357869-03:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ "si llego al final no puede comer"\r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:15',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ "si llego al final no puede comer"\r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[ "NO uso verificarEscaqueEnFila por que cuenta que puede comer para adelante"\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:18',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:25:13.927869-03:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ "si llego al final no puede comer"\r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[ "NO uso verificarEscaqueEnFila por que cuenta que puede comer para adelante"\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\rprimerMovimiento := false."Como si o si se va a realizar el movimiento lo seteo en false"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:18',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ "si llego al final no puede comer"\r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[ "NO uso verificarEscaqueEnFila por que cuenta que puede comer para adelante"\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\r"primerMovimiento := false.Como si o si se va a realizar el movimiento lo seteo en false  MAL"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:25',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:25:58.015869-03:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ "si llego al final no puede comer"\r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[ "NO uso verificarEscaqueEnFila por que cuenta que puede comer para adelante"\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\r"primerMovimiento := false.Como si o si se va a realizar el movimiento lo seteo en false  MAL"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:25',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ "si llego al final no puede comer"\r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[ "NO uso verificarEscaqueEnFila por que cuenta que puede comer para adelante"\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t\t\t\t\t\t\r\t\t\t\tprimerMovimiento := false.\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\r"primerMovimiento := false.Como si o si se va a realizar el movimiento lo seteo en false  MAL"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:25',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:26:09.357869-03:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ "si llego al final no puede comer"\r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[ "NO uso verificarEscaqueEnFila por que cuenta que puede comer para adelante"\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t\t\t\t\t\t\r\t\t\t\tprimerMovimiento := false.\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\r"primerMovimiento := false.Como si o si se va a realizar el movimiento lo seteo en false  MAL"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:25',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ "si llego al final no puede comer"\r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[ "NO uso verificarEscaqueEnFila por que cuenta que puede comer para adelante"\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por \t\t\t\tdelante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t\t\t\t\t\t\r\t\t\t\tprimerMovimiento := false."CORRECCION"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\r"primerMovimiento := false.Como si o si se va a realizar el movimiento lo seteo en false  MAL"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:26',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:41:14.637869-03:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Rey			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|listaMovimientos|\rcolPosiblesMovimientos reset.\rlistaMovimientos := self movimientoUnCasillero.\rlistaMovimientos do:[:movimiento| \r\t(((movimiento at:1)>0) & ((movimiento at:1)<9) & ((movimiento at:2)>0) & ((movimiento at:2)<9))\tifTrue:[\r\t\t(((movimiento at:1)=filaPieza) & ((movimiento at:2)=columnaPieza))ifFalse: [ \r\t\t\tself verificarEscaqueEnFila: (movimiento at:1) enColumna: (movimiento at:2)  enTablero: \t\t\tunTablero.\r\t\t].\r\t].\r].\r^colPosiblesMovimientos.',			#stamp : 'ManuelLatorre 8/19/2019 15:31',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Rey			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|listaMovimientos|\rcolPosiblesMovimientos reset.\rlistaMovimientos := self movimientoUnCasillero.\r\r"arriba y abajo los meti en arrays verifico que esten en los limites antes de probar los escaques"\rlistaMovimientos do:[:movimiento| \r\t(((movimiento at:1)>0) & ((movimiento at:1)<9) & ((movimiento at:2)>0) & ((movimiento at:2)<9))\tifTrue:[\r\t\t(((movimiento at:1)=filaPieza) & ((movimiento at:2)=columnaPieza))ifFalse: [ \r\t\t\tself verificarEscaqueEnFila: (movimiento at:1) enColumna: (movimiento at:2)  enTablero: \t\t\tunTablero.\r\t\t].\r\t].\r].\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:41',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:43:43.048869-03:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Partida			},			#name : #'crearPiezasBlancas:',			#protocol : #PiezasBlancas,			#sourceCode : 'crearPiezasBlancas: unTablero\r|miEscaque colPiezasBlancas|\rcolPiezasBlancas:= OrderedCollection new.\r"CREO PEONES"\r1 to: 8 do:[:col| \r\tmiEscaque:= unTablero escaqueAt: 2 at: col.\r\t(miEscaque) setPieza:(Peon new)."Seteo el peon al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenPeonBlanco. "Llamo un metodo para poder \tmodificar en el la direccion donde se encuentran las imagenes "\r\t((miEscaque) getPiezaEscaque)setFilaPieza: 2."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: col.\t\r\t\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."agrego y muestro el peon sobre el \tescaque"\r\t((miEscaque getPiezaEscaque) position: (miEscaque) position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t((miEscaque getPiezaEscaque)setPrimerMovimiento: true).\r\t].\r\r"CREO TORRES"\r\r\tmiEscaque:= unTablero escaqueAt: 1 at: 1.\r\t(miEscaque) setPieza:(Torre new)."Seteo la torre al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenTorreBlanca. \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 1.\t\r\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t\r\tmiEscaque:= unTablero escaqueAt: 1 at: 8.\r\t(miEscaque) setPieza:(Torre new)."Seteo la torre al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenTorreBlanca. \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 8.\t\r\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t\r\t"Creo caballos"\r\tmiEscaque:= unTablero escaqueAt: 1 at: 2.\r\t(miEscaque) setPieza:(Caballo new)."Seteo el peon al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenCaballoBlanco. \r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 2.\t\r\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t\r\t\r\tmiEscaque:= unTablero escaqueAt: 1 at: 7.\r\t(miEscaque) setPieza:(Caballo new)."Seteo el peon al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenCaballoBlanco. \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 7.\t\r\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t\r\t"CreoAlfiles"\r\t\r\tmiEscaque:= unTablero escaqueAt: 1 at: 3.\r\t(miEscaque) setPieza:(Alfil new)."Seteo el peon al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenAlfilBlanco. \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 3.\r\t\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t\r\tmiEscaque:= unTablero escaqueAt: 1 at: 6.\r\t(miEscaque) setPieza:(Alfil new)."Seteo el peon al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenAlfilBlanco . \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 6.\t\r\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t"Creo dama"\r\t\r\tmiEscaque:= unTablero escaqueAt: 1 at: 5.\r\t(miEscaque) setPieza:(Dama new )."Seteo el peon al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenDamaBlanca. \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 5.\t\r\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t"Creo rey"\r\t\r\tmiEscaque:= unTablero escaqueAt: 1 at: 4.\r\t(miEscaque) setPieza:(Rey new)."Seteo el rey al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenReyBlanco. \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 4.\t\r\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t\r\tcolPiezasBlancas do: [:pieza| pieza color: Color white ].\r\t\r\t^colPiezasBlancas.',			#stamp : 'ManuelLatorre 7/31/2019 14:06',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Partida			},			#name : #'crearPiezasBlancas:',			#protocol : #PiezasBlancas,			#sourceCode : 'crearPiezasBlancas: unTablero\r|miEscaque colPiezasBlancas|\rcolPiezasBlancas:= OrderedCollection new.\r"CREO PEONES"\r1 to: 8 do:[:col| \r\tmiEscaque:= unTablero escaqueAt: 2 at: col.\r\t(miEscaque) setPieza:(Peon new)."Seteo el peon al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenPeonBlanco. "Llamo un metodo para poder \tmodificar en el la direccion donde se encuentran las imagenes "\r\t((miEscaque) getPiezaEscaque)setFilaPieza: 2."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: col.\t\r\t\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."agrego y muestro el peon sobre el \tescaque"\r\t((miEscaque getPiezaEscaque) position: (miEscaque) position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque). "Agrego el peon a colPiezasBlancas"\r\t((miEscaque getPiezaEscaque)setPrimerMovimiento: true). "Indico que es el primer movimiento del peon"\r\t].\r\r"CREO TORRES"\r\r\tmiEscaque:= unTablero escaqueAt: 1 at: 1.\r\t(miEscaque) setPieza:(Torre new)."Seteo la torre al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenTorreBlanca. \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 1.\t\r\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t\r\tmiEscaque:= unTablero escaqueAt: 1 at: 8.\r\t(miEscaque) setPieza:(Torre new)."Seteo la torre al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenTorreBlanca. \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 8.\t\r\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t\r\t"Creo caballos"\r\tmiEscaque:= unTablero escaqueAt: 1 at: 2.\r\t(miEscaque) setPieza:(Caballo new)."Seteo el peon al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenCaballoBlanco. \r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 2.\t\r\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t\r\t\r\tmiEscaque:= unTablero escaqueAt: 1 at: 7.\r\t(miEscaque) setPieza:(Caballo new)."Seteo el peon al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenCaballoBlanco. \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 7.\t\r\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t\r\t"CreoAlfiles"\r\t\r\tmiEscaque:= unTablero escaqueAt: 1 at: 3.\r\t(miEscaque) setPieza:(Alfil new)."Seteo el peon al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenAlfilBlanco. \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 3.\r\t\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t\r\tmiEscaque:= unTablero escaqueAt: 1 at: 6.\r\t(miEscaque) setPieza:(Alfil new)."Seteo el peon al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenAlfilBlanco . \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 6.\t\r\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t"Creo dama"\r\t\r\tmiEscaque:= unTablero escaqueAt: 1 at: 5.\r\t(miEscaque) setPieza:(Dama new )."Seteo el peon al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenDamaBlanca. \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 5.\t\r\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t"Creo rey"\r\t\r\tmiEscaque:= unTablero escaqueAt: 1 at: 4.\r\t(miEscaque) setPieza:(Rey new)."Seteo el rey al escaque"\r\t((miEscaque) getPiezaEscaque)form: self imagenReyBlanco. \r\t((miEscaque) getPiezaEscaque)setFilaPieza: 1."seteo ubicacion de la pieza para identificarla de las otras"\r\t((miEscaque) getPiezaEscaque)setColumnaPieza: 4.\t\r\t\r\t(miEscaque) addMorph: ((miEscaque) getPiezaEscaque )."muestro el torre sobre el escaque"\r\t((miEscaque getPiezaEscaque ) position: miEscaque position)."Lo ubico en el escaque"\r\tcolPiezasBlancas add: (miEscaque getPiezaEscaque).\r\t\r\tcolPiezasBlancas do: [:pieza| pieza color: Color white ].\r\t\r\t^colPiezasBlancas.',			#stamp : 'Manu 11/11/2020 13:43',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:50:51.160869-03:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Partida			},			#name : #menuDeJuego,			#protocol : #Menu,			#sourceCode : 'menuDeJuego\r|menuInicio|\rmenuInicio:=UIManager default "Elije crear un juego (crea el tablero con piezas) o Salir"\rchooseFrom: #(\'CREAR jUEGO\' \'SALIR\')\rlines: #(1) message: \'Elija una Opcion\'.\r(menuInicio=1) ifTrue: [ \r\tmovimientosMax :=UIManager default request: \'Ingrese la cantidad de movimientos maximas permitidas entre ambos jugadores\' initialAnswer:\'Cantidad de movimientos maxima\'.\r\tmovimientosMax := movimientosMax asInteger.\r\ttablero openInWorld.\r\t]. \r(menuInicio=2)ifFalse:[ "no lo pongo dentro del ifTrue anterior ya que largaba mensajes Warning y de paso aprovecho el valor que devuelve seleccionar \'SALIR\', en caso de seleccionar \'SALIR\' el programa no hace nada y se cierra el Menu"\rself menuEmpezarJuego. \r].',			#stamp : 'ManuelLatorre 7/31/2019 17:07',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Partida			},			#name : #menuDeJuego,			#protocol : #Menu,			#sourceCode : 'menuDeJuego\r|menuInicio|\rmenuInicio:=UIManager default "Elije crear un juego (crea el tablero con piezas) o Salir"\rchooseFrom: #(\'CREAR jUEGO\' \'SALIR\')"Devuelve 1 o 2"\rlines: #(1) message: \'Elija una Opcion\'.\r(menuInicio=1) ifTrue: [ \r\tmovimientosMax :=UIManager default request: \'Ingrese la cantidad de movimientos maximas permitidas entre ambos jugadores\' initialAnswer:\'Cantidad de movimientos maxima\'.\r\tmovimientosMax := movimientosMax asInteger.\r\ttablero openInWorld.\r\t]. \r(menuInicio=2)ifFalse:[ "no lo pongo dentro del ifTrue anterior ya que largaba mensajes Warning y de paso aprovecho el valor que devuelve seleccionar \'SALIR\', en caso de seleccionar \'SALIR\' el programa no hace nada y se cierra el Menu"\rself menuEmpezarJuego. \r].',			#stamp : 'Manu 11/11/2020 13:50',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:54:35.667869-03:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Partida			},			#name : #menuEmpezarJuego,			#protocol : #Menu,			#sourceCode : 'menuEmpezarJuego "Menu que aparece si se selecciono \'CREAR PARTIDA\'"\r|menu turnoJugadorNum tablasRechazadas jugadorEnTurno jugadorFueraTurnoNum jugadorFueraTurno rendicion posiblesTablas noSaltar  piezaComida colPiezasJugadorEnTurno reyNegro reyBlanco cantMovimientos empate|\rturnoJugadorNum :=1."Como el jugador de piezas blancas esta en la posicion 1 de mi coleccion le asigno el primer turno a este"\rjugadorFueraTurnoNum:=2.\rnoSaltar:=true.\rganador:=nil.\rcantMovimientos:=0.\r\rjugadorEnTurno:= (colJugadores at: turnoJugadorNum ). "indico jugador con primer turno (piezas blancas)"\rjugadorFueraTurno :=(colJugadores at: jugadorFueraTurnoNum )."indico jugador fuera de turno (piezas negras)"\r\t\r\treyBlanco:= (jugadorEnTurno getColPiezas)at:16."el rey se encuentra en la posicion 16 en la coleccion de piezas ya que fue el ultimo en crearse y agregarse a esta"\r\treyNegro :=(jugadorFueraTurno getColPiezas)at:16.\r\rmenu:=UIManager default "Elije empezar con el juego o salir (Borra el tablero)"\rchooseFrom: #(\'JUGAR\' \'SALIR\')\rlines: #(1) message: \'Elija una Opcion\'.\r(menu=1)ifTrue: [\r\tjugadorEnTurno:= (colJugadores at: turnoJugadorNum ). "indico jugador con primer turno (piezas blancas)"\r\tjugadorFueraTurno :=(colJugadores at: turnoJugadorNum )."indico jugador fuera de turno (piezas negras)"\r\r[ ganador ] whileNil: [ "Mientras no termine el juego por empate, rendicion o jake mate"\r\ttablasRechazadas :=true.\r\tpiezaComida:=(jugadorEnTurno) menuOpcionesJugador: turnoJugadorNum ."Envio numero de jugador en turno para indicarlo en el menu. Resivo si se comio una pieza (y cual) para poder quitarla de la coleccion de piezas del otro jugador si no se comio ninguna se resive nil".\r\t\r"Victoria jugador"\r((piezaComida = reyBlanco)|(piezaComida = reyNegro))ifTrue: [ \r\tganador:= \'Jugador: \',turnoJugadorNum asString.\r\tUIManager default alert:(\'Ganador: \',ganador) title: \'UN REY A SIDO TOMADO\'.\r\t ].\t\r\t\r"ELIMINO PIEZA COMIDA POR EL JUGADOR ANTERIOR DE LA COLECCION DEL JUGADOR EN TURNO ACTUAL"\r(ganador)ifNil: [ "Si no se comio al rey elimino la pieza de la coleccion caso contrario salteo"\r\t(piezaComida )ifNotNil: [ \r\t\tcolPiezasJugadorEnTurno := jugadorFueraTurno getColPiezas.\r\t\tcolPiezasJugadorEnTurno remove: piezaComida .\r\t\t ].\r\t].\r\r"UN JUGADOR SE RINDE (1)"\t\r\t\trendicion:=(jugadorEnTurno getRendicion)."Verifica si el jugador elijio rendirce"\r\r"SE PROPONEN TABLAS"\r\t\tposiblesTablas:=(jugadorEnTurno getTablas)."Verifica si el jugador prouso tablas"\r\t\t(posiblesTablas)ifTrue: [ \r\t\tempate:=(jugadorFueraTurno menuTablas: jugadorFueraTurnoNum)."Pregunto al otro jugador si quiere aceptar las tablas"\r\t(empate) ifTrue: [ganador := \'EMPATE\'.\r\t\t\tUIManager default alert:(\'La partida se resolvio en tablas\') title: \'FIN DEL JUEGO\'.\r\t\t\t]."Si acepta indico que termino el juego"\r\t(empate) ifFalse: [posiblesTablas:= false.\r\t\t\tUIManager default alert: \'El adversario rechazo la propuesta de tablas elija una opcion\' title: \'Jugador \',turnoJugadorNum asString.\r\t\t\ttablasRechazadas:=false.\r\t\t\tjugadorEnTurno setTablas: false."seteo nuevamente en false la variable tablas del jugador que propuso (Se modificaba en menuOpcionesJugador a true cuando ofrecia tablas)"\r\t\t\t\t]."Si el otro jugador lo rechaza le indico al jugador que rechazaron la propuesta y seteo tablasrechazadas en true para que no se produzca un cambio de turno y que el jugador que propuso no pierda su turno y elija una opcion nuevamente"\r\t\t\t ].\r\t\t\r"UN JUGADOR TERMINA SU TURNO Y PASA AL SIGUIENTE JUGADOR"\t\t\r(tablasRechazadas & (ganador isNil)) ifTrue: [  "Si se rechazaron tablas esto hace que el jugador que las propuso no pierda su turno"\r\tnoSaltar :=true.\r\t(turnoJugadorNum=1)ifTrue: [jugadorFueraTurnoNum :=turnoJugadorNum.\r\t\t turnoJugadorNum :=2. \r\t\t noSaltar :=false. "Lo utilizo para indicar que ya se hizo un cambio"\r\t\t]."Intercambio los turnos"\r\t\t(turnoJugadorNum=2 & noSaltar)ifTrue: [ jugadorFueraTurnoNum :=turnoJugadorNum.\r\t\tturnoJugadorNum:=1.\r\t\t ].\r\tjugadorEnTurno:= (colJugadores at: turnoJugadorNum )."jugador1: piezas blancas jugador2 piezas negras."\r\tjugadorFueraTurno :=(colJugadores at: jugadorFueraTurnoNum ).\r\t].\r\t\r"UN JUGADOR SE RINDE (2)"\t\r(rendicion)ifTrue: [ ganador:= (jugadorEnTurno asString).\r\tUIManager default alert:(\'Ganador: Jugador\',turnoJugadorNum asString) title: \'UN JUGADOR SE A RENDIDO\'.].\r\r"SUMO MOVIMIENTO Y VERIFICO SI SE EXEDIO PARA TERMINAR EL JUEGO EN TABLAS"\rcantMovimientos := cantMovimientos +1.\r(cantMovimientos >= movimientosMax )ifTrue: [ ganador := \'EMPATE\'.\r\t\t\tUIManager default alert:(\'La partida se resolvio en tablas por que se realizo la cantidad de movimientos preestablecida por los jugadores\') title: \'FIN DEL JUEGO\'.\r\t\t\t].\r\t ].\r"FIN DEL JUEGO"\r\ttablero delete."si sale de while significa que termino la partida por lo tanto borro el tablero"\r].\r(menu=2)ifTrue: [\r\ttablero delete. "Si elije \'SALIR\' borro el Morph tablero (como las piezas \'estan a‚àö¬±adidas\' a este tambien desaparecen"\r\t ].',			#stamp : 'ManuelLatorre 8/4/2019 14:59',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Partida			},			#name : #menuEmpezarJuego,			#protocol : #Menu,			#sourceCode : 'menuEmpezarJuego "Menu que aparece si se selecciono \'CREAR PARTIDA\'"\r|menu turnoJugadorNum tablasRechazadas jugadorEnTurno jugadorFueraTurnoNum jugadorFueraTurno rendicion posiblesTablas noSaltar  piezaComida colPiezasJugadorEnTurno reyNegro reyBlanco cantMovimientos empate|\rturnoJugadorNum :=1."Como el jugador de piezas blancas esta en la posicion 1 de mi coleccion le asigno el primer turno a este"\rjugadorFueraTurnoNum:=2.\rnoSaltar:=true.\rganador:=nil.\rcantMovimientos:=0.\r\rjugadorEnTurno:= (colJugadores at: turnoJugadorNum ). "indico jugador con primer turno (piezas blancas)"\rjugadorFueraTurno :=(colJugadores at: jugadorFueraTurnoNum )."indico jugador fuera de turno (piezas negras)"\r\t\r\treyBlanco:= (jugadorEnTurno getColPiezas)at:16."el rey se encuentra en la posicion 16 en la coleccion de piezas ya que fue el ultimo en crearse y agregarse a esta"\r\treyNegro :=(jugadorFueraTurno getColPiezas)at:16.\r\rmenu:=UIManager default "Elije empezar con el juego o salir (Borra el tablero)"\rchooseFrom: #(\'JUGAR\' \'SALIR\')\rlines: #(1) message: \'Elija una Opcion\'.\r(menu=1)ifTrue: [\r\tjugadorEnTurno:= (colJugadores at: turnoJugadorNum ). "indico jugador con primer turno (piezas blancas)"\r\tjugadorFueraTurno :=(colJugadores at: turnoJugadorNum )."indico jugador fuera de turno (piezas negras)"\r\r[ ganador ] whileNil: [ "Mientras no termine el juego por empate, rendicion o jake mate"\r\ttablasRechazadas :=true.\r\tpiezaComida:=(jugadorEnTurno) menuOpcionesJugador: turnoJugadorNum ."Envio numero de jugador en turno para indicarlo en el menu. Resibo si se comio una pieza (y cual) para poder quitarla de la coleccion de piezas del otro jugador si no se comio ninguna se resibe nil".\r\t\r"Victoria jugador"\r((piezaComida = reyBlanco)|(piezaComida = reyNegro))ifTrue: [ \r\tganador:= \'Jugador: \',turnoJugadorNum asString.\r\tUIManager default alert:(\'Ganador: \',ganador) title: \'UN REY A SIDO TOMADO\'.\r\t ].\t\r\t\r"ELIMINO PIEZA COMIDA POR EL JUGADOR ANTERIOR DE LA COLECCION DEL JUGADOR EN TURNO ACTUAL"\r(ganador)ifNil: [ "Si no se comio al rey elimino la pieza de la coleccion caso contrario salteo"\r\t(piezaComida )ifNotNil: [ \r\t\tcolPiezasJugadorEnTurno := jugadorFueraTurno getColPiezas.\r\t\tcolPiezasJugadorEnTurno remove: piezaComida .\r\t\t ].\r\t].\r\r"UN JUGADOR SE RINDE (1)"\t\r\t\trendicion:=(jugadorEnTurno getRendicion)."Verifica si el jugador elijio rendirce"\r\r"SE PROPONEN TABLAS"\r\t\tposiblesTablas:=(jugadorEnTurno getTablas)."Verifica si el jugador prouso tablas"\r\t\t(posiblesTablas)ifTrue: [ \r\t\tempate:=(jugadorFueraTurno menuTablas: jugadorFueraTurnoNum)."Pregunto al otro jugador si quiere aceptar las tablas"\r\t(empate) ifTrue: [ganador := \'EMPATE\'.\r\t\t\tUIManager default alert:(\'La partida se resolvio en tablas\') title: \'FIN DEL JUEGO\'.\r\t\t\t]."Si acepta indico que termino el juego"\r\t(empate) ifFalse: [posiblesTablas:= false.\r\t\t\tUIManager default alert: \'El adversario rechazo la propuesta de tablas elija una opcion\' title: \'Jugador \',turnoJugadorNum asString.\r\t\t\ttablasRechazadas:=false.\r\t\t\tjugadorEnTurno setTablas: false."seteo nuevamente en false la variable tablas del jugador que propuso (Se modificaba en menuOpcionesJugador a true cuando ofrecia tablas)"\r\t\t\t\t]."Si el otro jugador lo rechaza le indico al jugador que rechazaron la propuesta y seteo tablasrechazadas en true para que no se produzca un cambio de turno y que el jugador que propuso no pierda su turno y elija una opcion nuevamente"\r\t\t\t ].\r\t\t\r"UN JUGADOR TERMINA SU TURNO Y PASA AL SIGUIENTE JUGADOR"\t\t\r(tablasRechazadas & (ganador isNil)) ifTrue: [  "Si se rechazaron tablas esto hace que el jugador que las propuso no pierda su turno"\r\tnoSaltar :=true.\r\t(turnoJugadorNum=1)ifTrue: [jugadorFueraTurnoNum :=turnoJugadorNum.\r\t\t turnoJugadorNum :=2. \r\t\t noSaltar :=false. "Lo utilizo para indicar que ya se hizo un cambio"\r\t\t]."Intercambio los turnos"\r\t\t(turnoJugadorNum=2 & noSaltar)ifTrue: [ jugadorFueraTurnoNum :=turnoJugadorNum.\r\t\tturnoJugadorNum:=1.\r\t\t ].\r\tjugadorEnTurno:= (colJugadores at: turnoJugadorNum )."jugador1: piezas blancas jugador2 piezas negras."\r\tjugadorFueraTurno :=(colJugadores at: jugadorFueraTurnoNum ).\r\t].\r\t\r"UN JUGADOR SE RINDE (2)"\t\r(rendicion)ifTrue: [ ganador:= (jugadorEnTurno asString).\r\tUIManager default alert:(\'Ganador: Jugador\',turnoJugadorNum asString) title: \'UN JUGADOR SE A RENDIDO\'.].\r\r"SUMO MOVIMIENTO Y VERIFICO SI SE EXEDIO PARA TERMINAR EL JUEGO EN TABLAS"\rcantMovimientos := cantMovimientos +1.\r(cantMovimientos >= movimientosMax )ifTrue: [ ganador := \'EMPATE\'.\r\t\t\tUIManager default alert:(\'La partida se resolvio en tablas por que se realizo la cantidad de movimientos preestablecida por los jugadores\') title: \'FIN DEL JUEGO\'.\r\t\t\t].\r\t ].\r"FIN DEL JUEGO"\r\ttablero delete."si sale de while significa que termino la partida por lo tanto borro el tablero"\r].\r(menu=2)ifTrue: [\r\ttablero delete. "Si elije \'SALIR\' borro el Morph tablero (como las piezas \'estan a‚àö¬±adidas\' a este tambien desaparecen"\r\t ].',			#stamp : 'Manu 11/11/2020 13:54',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:56:03.345869-03:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Partida			},			#name : #menuEmpezarJuego,			#protocol : #Menu,			#sourceCode : 'menuEmpezarJuego "Menu que aparece si se selecciono \'CREAR PARTIDA\'"\r|menu turnoJugadorNum tablasRechazadas jugadorEnTurno jugadorFueraTurnoNum jugadorFueraTurno rendicion posiblesTablas noSaltar  piezaComida colPiezasJugadorEnTurno reyNegro reyBlanco cantMovimientos empate|\rturnoJugadorNum :=1."Como el jugador de piezas blancas esta en la posicion 1 de mi coleccion le asigno el primer turno a este"\rjugadorFueraTurnoNum:=2.\rnoSaltar:=true.\rganador:=nil.\rcantMovimientos:=0.\r\rjugadorEnTurno:= (colJugadores at: turnoJugadorNum ). "indico jugador con primer turno (piezas blancas)"\rjugadorFueraTurno :=(colJugadores at: jugadorFueraTurnoNum )."indico jugador fuera de turno (piezas negras)"\r\t\r\treyBlanco:= (jugadorEnTurno getColPiezas)at:16."el rey se encuentra en la posicion 16 en la coleccion de piezas ya que fue el ultimo en crearse y agregarse a esta"\r\treyNegro :=(jugadorFueraTurno getColPiezas)at:16.\r\rmenu:=UIManager default "Elije empezar con el juego o salir (Borra el tablero)"\rchooseFrom: #(\'JUGAR\' \'SALIR\')\rlines: #(1) message: \'Elija una Opcion\'.\r(menu=1)ifTrue: [\r\tjugadorEnTurno:= (colJugadores at: turnoJugadorNum ). "indico jugador con primer turno (piezas blancas)"\r\tjugadorFueraTurno :=(colJugadores at: turnoJugadorNum )."indico jugador fuera de turno (piezas negras)"\r\r[ ganador ] whileNil: [ "Mientras no termine el juego por empate, rendicion o jake mate"\r\ttablasRechazadas :=true.\r\tpiezaComida:=(jugadorEnTurno) menuOpcionesJugador: turnoJugadorNum ."Envio numero de jugador en turno para indicarlo en el menu. Resibo si se comio una pieza (y cual) para poder quitarla de la coleccion de piezas del otro jugador si no se comio ninguna se resibe nil".\r\t\r"Victoria jugador"\r((piezaComida = reyBlanco)|(piezaComida = reyNegro))ifTrue: [ \r\tganador:= \'Jugador: \',turnoJugadorNum asString.\r\tUIManager default alert:(\'Ganador: \',ganador) title: \'UN REY A SIDO TOMADO\'.\r\t ].\t\r\t\r"ELIMINO PIEZA COMIDA POR EL JUGADOR ANTERIOR DE LA COLECCION DEL JUGADOR EN TURNO ACTUAL"\r(ganador)ifNil: [ "Si no se comio al rey elimino la pieza de la coleccion caso contrario salteo"\r\t(piezaComida )ifNotNil: [ \r\t\tcolPiezasJugadorEnTurno := jugadorFueraTurno getColPiezas.\r\t\tcolPiezasJugadorEnTurno remove: piezaComida .\r\t\t ].\r\t].\r\r"UN JUGADOR SE RINDE (1)"\t\r\t\trendicion:=(jugadorEnTurno getRendicion)."Verifica si el jugador elijio rendirce"\r\r"SE PROPONEN TABLAS"\r\t\tposiblesTablas:=(jugadorEnTurno getTablas)."Verifica si el jugador prouso tablas"\r\t\t(posiblesTablas)ifTrue: [ \r\t\tempate:=(jugadorFueraTurno menuTablas: jugadorFueraTurnoNum)."Pregunto al otro jugador si quiere aceptar las tablas"\r\t(empate) ifTrue: [ganador := \'EMPATE\'.\r\t\t\tUIManager default alert:(\'La partida se resolvio en tablas\') title: \'FIN DEL JUEGO\'.\r\t\t\t]."Si acepta indico que termino el juego"\r\t(empate) ifFalse: [posiblesTablas:= false.\r\t\t\tUIManager default alert: \'El adversario rechazo la propuesta de tablas elija una opcion\' title: \'Jugador \',turnoJugadorNum asString.\r\t\t\ttablasRechazadas:=false.\r\t\t\tjugadorEnTurno setTablas: false."seteo nuevamente en false la variable tablas del jugador que propuso (Se modificaba en menuOpcionesJugador a true cuando ofrecia tablas)"\r\t\t\t\t]."Si el otro jugador lo rechaza le indico al jugador que rechazaron la propuesta y seteo tablasrechazadas en true para que no se produzca un cambio de turno y que el jugador que propuso no pierda su turno y elija una opcion nuevamente"\r\t\t\t ].\r\t\t\r"UN JUGADOR TERMINA SU TURNO Y PASA AL SIGUIENTE JUGADOR"\t\t\r(tablasRechazadas & (ganador isNil)) ifTrue: [  "Si se rechazaron tablas esto hace que el jugador que las propuso no pierda su turno"\r\tnoSaltar :=true.\r\t(turnoJugadorNum=1)ifTrue: [jugadorFueraTurnoNum :=turnoJugadorNum.\r\t\t turnoJugadorNum :=2. \r\t\t noSaltar :=false. "Lo utilizo para indicar que ya se hizo un cambio"\r\t\t]."Intercambio los turnos"\r\t\t(turnoJugadorNum=2 & noSaltar)ifTrue: [ jugadorFueraTurnoNum :=turnoJugadorNum.\r\t\tturnoJugadorNum:=1.\r\t\t ].\r\tjugadorEnTurno:= (colJugadores at: turnoJugadorNum )."jugador1: piezas blancas jugador2 piezas negras."\r\tjugadorFueraTurno :=(colJugadores at: jugadorFueraTurnoNum ).\r\t].\r\t\r"UN JUGADOR SE RINDE (2)"\t\r(rendicion)ifTrue: [ ganador:= (jugadorEnTurno asString).\r\tUIManager default alert:(\'Ganador: Jugador\',turnoJugadorNum asString) title: \'UN JUGADOR SE A RENDIDO\'.].\r\r"SUMO MOVIMIENTO Y VERIFICO SI SE EXEDIO PARA TERMINAR EL JUEGO EN TABLAS"\rcantMovimientos := cantMovimientos +1.\r(cantMovimientos >= movimientosMax )ifTrue: [ ganador := \'EMPATE\'.\r\t\t\tUIManager default alert:(\'La partida se resolvio en tablas por que se realizo la cantidad de movimientos preestablecida por los jugadores\') title: \'FIN DEL JUEGO\'.\r\t\t\t].\r\t ].\r"FIN DEL JUEGO"\r\ttablero delete."si sale de while significa que termino la partida por lo tanto borro el tablero"\r].\r(menu=2)ifTrue: [\r\ttablero delete. "Si elije \'SALIR\' borro el Morph tablero (como las piezas \'estan a‚àö¬±adidas\' a este tambien desaparecen"\r\t ].',			#stamp : 'Manu 11/11/2020 13:54',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Partida			},			#name : #menuEmpezarJuego,			#protocol : #Menu,			#sourceCode : 'menuEmpezarJuego "Menu que aparece si se selecciono \'CREAR PARTIDA\'"\r|menu turnoJugadorNum tablasRechazadas jugadorEnTurno jugadorFueraTurnoNum jugadorFueraTurno rendicion posiblesTablas noSaltar  piezaComida colPiezasJugadorEnTurno reyNegro reyBlanco cantMovimientos empate|\rturnoJugadorNum :=1."Como el jugador de piezas blancas esta en la posicion 1 de mi coleccion le asigno el primer turno a este"\rjugadorFueraTurnoNum:=2.\rnoSaltar:=true.\rganador:=nil.\rcantMovimientos:=0.\r\rjugadorEnTurno:= (colJugadores at: turnoJugadorNum ). "indico jugador con primer turno (piezas blancas)"\rjugadorFueraTurno :=(colJugadores at: jugadorFueraTurnoNum )."indico jugador fuera de turno (piezas negras)"\r\t\r\treyBlanco:= (jugadorEnTurno getColPiezas)at:16."el rey se encuentra en la posicion 16 en la coleccion de piezas ya que fue el ultimo en crearse y agregarse a esta"\r\treyNegro :=(jugadorFueraTurno getColPiezas)at:16.\r\rmenu:=UIManager default "Elije empezar con el juego o salir (Borra el tablero)"\rchooseFrom: #(\'JUGAR\' \'SALIR\')\rlines: #(1) message: \'Elija una Opcion\'.\r(menu=1)ifTrue: [\r\tjugadorEnTurno:= (colJugadores at: turnoJugadorNum ). "indico jugador con primer turno (piezas blancas)"\r\tjugadorFueraTurno :=(colJugadores at: turnoJugadorNum )."indico jugador fuera de turno (piezas negras)"\r\r[ ganador ] whileNil: [ "Mientras no termine el juego por empate, rendicion o jake mate"\r\ttablasRechazadas :=true.\r\tpiezaComida:=(jugadorEnTurno) menuOpcionesJugador: turnoJugadorNum ."Envio numero de jugador en turno para indicarlo en el menu. Recibo si se comio una pieza (y cual) para poder quitarla de la coleccion de piezas del otro jugador si no se comio ninguna se resibe nil".\r\t\r"Victoria jugador"\r((piezaComida = reyBlanco)|(piezaComida = reyNegro))ifTrue: [ \r\tganador:= \'Jugador: \',turnoJugadorNum asString.\r\tUIManager default alert:(\'Ganador: \',ganador) title: \'UN REY A SIDO TOMADO\'.\r\t ].\t\r\t\r"ELIMINO PIEZA COMIDA POR EL JUGADOR ANTERIOR DE LA COLECCION DEL JUGADOR EN TURNO ACTUAL"\r(ganador)ifNil: [ "Si no se comio al rey elimino la pieza de la coleccion caso contrario salteo"\r\t(piezaComida )ifNotNil: [ \r\t\tcolPiezasJugadorEnTurno := jugadorFueraTurno getColPiezas.\r\t\tcolPiezasJugadorEnTurno remove: piezaComida .\r\t\t ].\r\t].\r\r"UN JUGADOR SE RINDE (1)"\t\r\t\trendicion:=(jugadorEnTurno getRendicion)."Verifica si el jugador elijio rendirce"\r\r"SE PROPONEN TABLAS"\r\t\tposiblesTablas:=(jugadorEnTurno getTablas)."Verifica si el jugador prouso tablas"\r\t\t(posiblesTablas)ifTrue: [ \r\t\tempate:=(jugadorFueraTurno menuTablas: jugadorFueraTurnoNum)."Pregunto al otro jugador si quiere aceptar las tablas"\r\t(empate) ifTrue: [ganador := \'EMPATE\'.\r\t\t\tUIManager default alert:(\'La partida se resolvio en tablas\') title: \'FIN DEL JUEGO\'.\r\t\t\t]."Si acepta indico que termino el juego"\r\t(empate) ifFalse: [posiblesTablas:= false.\r\t\t\tUIManager default alert: \'El adversario rechazo la propuesta de tablas elija una opcion\' title: \'Jugador \',turnoJugadorNum asString.\r\t\t\ttablasRechazadas:=false.\r\t\t\tjugadorEnTurno setTablas: false."seteo nuevamente en false la variable tablas del jugador que propuso (Se modificaba en menuOpcionesJugador a true cuando ofrecia tablas)"\r\t\t\t\t]."Si el otro jugador lo rechaza le indico al jugador que rechazaron la propuesta y seteo tablasrechazadas en true para que no se produzca un cambio de turno y que el jugador que propuso no pierda su turno y elija una opcion nuevamente"\r\t\t\t ].\r\t\t\r"UN JUGADOR TERMINA SU TURNO Y PASA AL SIGUIENTE JUGADOR"\t\t\r(tablasRechazadas & (ganador isNil)) ifTrue: [  "Si se rechazaron tablas esto hace que el jugador que las propuso no pierda su turno"\r\tnoSaltar :=true.\r\t(turnoJugadorNum=1)ifTrue: [jugadorFueraTurnoNum :=turnoJugadorNum.\r\t\t turnoJugadorNum :=2. \r\t\t noSaltar :=false. "Lo utilizo para indicar que ya se hizo un cambio"\r\t\t]."Intercambio los turnos"\r\t\t(turnoJugadorNum=2 & noSaltar)ifTrue: [ jugadorFueraTurnoNum :=turnoJugadorNum.\r\t\tturnoJugadorNum:=1.\r\t\t ].\r\tjugadorEnTurno:= (colJugadores at: turnoJugadorNum )."jugador1: piezas blancas jugador2 piezas negras."\r\tjugadorFueraTurno :=(colJugadores at: jugadorFueraTurnoNum ).\r\t].\r\t\r"UN JUGADOR SE RINDE (2)"\t\r(rendicion)ifTrue: [ ganador:= (jugadorEnTurno asString).\r\tUIManager default alert:(\'Ganador: Jugador\',turnoJugadorNum asString) title: \'UN JUGADOR SE A RENDIDO\'.].\r\r"SUMO MOVIMIENTO Y VERIFICO SI SE EXEDIO PARA TERMINAR EL JUEGO EN TABLAS"\rcantMovimientos := cantMovimientos +1.\r(cantMovimientos >= movimientosMax )ifTrue: [ ganador := \'EMPATE\'.\r\t\t\tUIManager default alert:(\'La partida se resolvio en tablas por que se realizo la cantidad de movimientos preestablecida por los jugadores\') title: \'FIN DEL JUEGO\'.\r\t\t\t].\r\t ].\r"FIN DEL JUEGO"\r\ttablero delete."si sale de while significa que termino la partida por lo tanto borro el tablero"\r].\r(menu=2)ifTrue: [\r\ttablero delete. "Si elije \'SALIR\' borro el Morph tablero (como las piezas \'estan a‚àö¬±adidas\' a este tambien desaparecen"\r\t ].',			#stamp : 'Manu 11/11/2020 13:56',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2020-11-11T13:56:13.113869-03:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Partida			},			#name : #menuEmpezarJuego,			#protocol : #Menu,			#sourceCode : 'menuEmpezarJuego "Menu que aparece si se selecciono \'CREAR PARTIDA\'"\r|menu turnoJugadorNum tablasRechazadas jugadorEnTurno jugadorFueraTurnoNum jugadorFueraTurno rendicion posiblesTablas noSaltar  piezaComida colPiezasJugadorEnTurno reyNegro reyBlanco cantMovimientos empate|\rturnoJugadorNum :=1."Como el jugador de piezas blancas esta en la posicion 1 de mi coleccion le asigno el primer turno a este"\rjugadorFueraTurnoNum:=2.\rnoSaltar:=true.\rganador:=nil.\rcantMovimientos:=0.\r\rjugadorEnTurno:= (colJugadores at: turnoJugadorNum ). "indico jugador con primer turno (piezas blancas)"\rjugadorFueraTurno :=(colJugadores at: jugadorFueraTurnoNum )."indico jugador fuera de turno (piezas negras)"\r\t\r\treyBlanco:= (jugadorEnTurno getColPiezas)at:16."el rey se encuentra en la posicion 16 en la coleccion de piezas ya que fue el ultimo en crearse y agregarse a esta"\r\treyNegro :=(jugadorFueraTurno getColPiezas)at:16.\r\rmenu:=UIManager default "Elije empezar con el juego o salir (Borra el tablero)"\rchooseFrom: #(\'JUGAR\' \'SALIR\')\rlines: #(1) message: \'Elija una Opcion\'.\r(menu=1)ifTrue: [\r\tjugadorEnTurno:= (colJugadores at: turnoJugadorNum ). "indico jugador con primer turno (piezas blancas)"\r\tjugadorFueraTurno :=(colJugadores at: turnoJugadorNum )."indico jugador fuera de turno (piezas negras)"\r\r[ ganador ] whileNil: [ "Mientras no termine el juego por empate, rendicion o jake mate"\r\ttablasRechazadas :=true.\r\tpiezaComida:=(jugadorEnTurno) menuOpcionesJugador: turnoJugadorNum ."Envio numero de jugador en turno para indicarlo en el menu. Recibo si se comio una pieza (y cual) para poder quitarla de la coleccion de piezas del otro jugador si no se comio ninguna se resibe nil".\r\t\r"Victoria jugador"\r((piezaComida = reyBlanco)|(piezaComida = reyNegro))ifTrue: [ \r\tganador:= \'Jugador: \',turnoJugadorNum asString.\r\tUIManager default alert:(\'Ganador: \',ganador) title: \'UN REY A SIDO TOMADO\'.\r\t ].\t\r\t\r"ELIMINO PIEZA COMIDA POR EL JUGADOR ANTERIOR DE LA COLECCION DEL JUGADOR EN TURNO ACTUAL"\r(ganador)ifNil: [ "Si no se comio al rey elimino la pieza de la coleccion caso contrario salteo"\r\t(piezaComida )ifNotNil: [ \r\t\tcolPiezasJugadorEnTurno := jugadorFueraTurno getColPiezas.\r\t\tcolPiezasJugadorEnTurno remove: piezaComida .\r\t\t ].\r\t].\r\r"UN JUGADOR SE RINDE (1)"\t\r\t\trendicion:=(jugadorEnTurno getRendicion)."Verifica si el jugador elijio rendirce"\r\r"SE PROPONEN TABLAS"\r\t\tposiblesTablas:=(jugadorEnTurno getTablas)."Verifica si el jugador prouso tablas"\r\t\t(posiblesTablas)ifTrue: [ \r\t\tempate:=(jugadorFueraTurno menuTablas: jugadorFueraTurnoNum)."Pregunto al otro jugador si quiere aceptar las tablas"\r\t(empate) ifTrue: [ganador := \'EMPATE\'.\r\t\t\tUIManager default alert:(\'La partida se resolvio en tablas\') title: \'FIN DEL JUEGO\'.\r\t\t\t]."Si acepta indico que termino el juego"\r\t(empate) ifFalse: [posiblesTablas:= false.\r\t\t\tUIManager default alert: \'El adversario rechazo la propuesta de tablas elija una opcion\' title: \'Jugador \',turnoJugadorNum asString.\r\t\t\ttablasRechazadas:=false.\r\t\t\tjugadorEnTurno setTablas: false."seteo nuevamente en false la variable tablas del jugador que propuso (Se modificaba en menuOpcionesJugador a true cuando ofrecia tablas)"\r\t\t\t\t]."Si el otro jugador lo rechaza le indico al jugador que rechazaron la propuesta y seteo tablasrechazadas en true para que no se produzca un cambio de turno y que el jugador que propuso no pierda su turno y elija una opcion nuevamente"\r\t\t\t ].\r\t\t\r"UN JUGADOR TERMINA SU TURNO Y PASA AL SIGUIENTE JUGADOR"\t\t\r(tablasRechazadas & (ganador isNil)) ifTrue: [  "Si se rechazaron tablas esto hace que el jugador que las propuso no pierda su turno"\r\tnoSaltar :=true.\r\t(turnoJugadorNum=1)ifTrue: [jugadorFueraTurnoNum :=turnoJugadorNum.\r\t\t turnoJugadorNum :=2. \r\t\t noSaltar :=false. "Lo utilizo para indicar que ya se hizo un cambio"\r\t\t]."Intercambio los turnos"\r\t\t(turnoJugadorNum=2 & noSaltar)ifTrue: [ jugadorFueraTurnoNum :=turnoJugadorNum.\r\t\tturnoJugadorNum:=1.\r\t\t ].\r\tjugadorEnTurno:= (colJugadores at: turnoJugadorNum )."jugador1: piezas blancas jugador2 piezas negras."\r\tjugadorFueraTurno :=(colJugadores at: jugadorFueraTurnoNum ).\r\t].\r\t\r"UN JUGADOR SE RINDE (2)"\t\r(rendicion)ifTrue: [ ganador:= (jugadorEnTurno asString).\r\tUIManager default alert:(\'Ganador: Jugador\',turnoJugadorNum asString) title: \'UN JUGADOR SE A RENDIDO\'.].\r\r"SUMO MOVIMIENTO Y VERIFICO SI SE EXEDIO PARA TERMINAR EL JUEGO EN TABLAS"\rcantMovimientos := cantMovimientos +1.\r(cantMovimientos >= movimientosMax )ifTrue: [ ganador := \'EMPATE\'.\r\t\t\tUIManager default alert:(\'La partida se resolvio en tablas por que se realizo la cantidad de movimientos preestablecida por los jugadores\') title: \'FIN DEL JUEGO\'.\r\t\t\t].\r\t ].\r"FIN DEL JUEGO"\r\ttablero delete."si sale de while significa que termino la partida por lo tanto borro el tablero"\r].\r(menu=2)ifTrue: [\r\ttablero delete. "Si elije \'SALIR\' borro el Morph tablero (como las piezas \'estan a‚àö¬±adidas\' a este tambien desaparecen"\r\t ].',			#stamp : 'Manu 11/11/2020 13:56',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Partida			},			#name : #menuEmpezarJuego,			#protocol : #Menu,			#sourceCode : 'menuEmpezarJuego "Menu que aparece si se selecciono \'CREAR PARTIDA\'"\r|menu turnoJugadorNum tablasRechazadas jugadorEnTurno jugadorFueraTurnoNum jugadorFueraTurno rendicion posiblesTablas noSaltar  piezaComida colPiezasJugadorEnTurno reyNegro reyBlanco cantMovimientos empate|\rturnoJugadorNum :=1."Como el jugador de piezas blancas esta en la posicion 1 de mi coleccion le asigno el primer turno a este"\rjugadorFueraTurnoNum:=2.\rnoSaltar:=true.\rganador:=nil.\rcantMovimientos:=0.\r\rjugadorEnTurno:= (colJugadores at: turnoJugadorNum ). "indico jugador con primer turno (piezas blancas)"\rjugadorFueraTurno :=(colJugadores at: jugadorFueraTurnoNum )."indico jugador fuera de turno (piezas negras)"\r\t\r\treyBlanco:= (jugadorEnTurno getColPiezas)at:16."el rey se encuentra en la posicion 16 en la coleccion de piezas ya que fue el ultimo en crearse y agregarse a esta"\r\treyNegro :=(jugadorFueraTurno getColPiezas)at:16.\r\rmenu:=UIManager default "Elije empezar con el juego o salir (Borra el tablero)"\rchooseFrom: #(\'JUGAR\' \'SALIR\')\rlines: #(1) message: \'Elija una Opcion\'.\r(menu=1)ifTrue: [\r\tjugadorEnTurno:= (colJugadores at: turnoJugadorNum ). "indico jugador con primer turno (piezas blancas)"\r\tjugadorFueraTurno :=(colJugadores at: turnoJugadorNum )."indico jugador fuera de turno (piezas negras)"\r\r[ ganador ] whileNil: [ "Mientras no termine el juego por empate, rendicion o jake mate"\r\ttablasRechazadas :=true.\r\tpiezaComida:=(jugadorEnTurno) menuOpcionesJugador: turnoJugadorNum ."Envio numero de jugador en turno para indicarlo en el menu. Recibo si se comio una pieza (y cual) para poder quitarla de la coleccion de piezas del otro jugador si no se comio ninguna se recibe nil".\r\t\r"Victoria jugador"\r((piezaComida = reyBlanco)|(piezaComida = reyNegro))ifTrue: [ \r\tganador:= \'Jugador: \',turnoJugadorNum asString.\r\tUIManager default alert:(\'Ganador: \',ganador) title: \'UN REY A SIDO TOMADO\'.\r\t ].\t\r\t\r"ELIMINO PIEZA COMIDA POR EL JUGADOR ANTERIOR DE LA COLECCION DEL JUGADOR EN TURNO ACTUAL"\r(ganador)ifNil: [ "Si no se comio al rey elimino la pieza de la coleccion caso contrario salteo"\r\t(piezaComida )ifNotNil: [ \r\t\tcolPiezasJugadorEnTurno := jugadorFueraTurno getColPiezas.\r\t\tcolPiezasJugadorEnTurno remove: piezaComida .\r\t\t ].\r\t].\r\r"UN JUGADOR SE RINDE (1)"\t\r\t\trendicion:=(jugadorEnTurno getRendicion)."Verifica si el jugador elijio rendirce"\r\r"SE PROPONEN TABLAS"\r\t\tposiblesTablas:=(jugadorEnTurno getTablas)."Verifica si el jugador prouso tablas"\r\t\t(posiblesTablas)ifTrue: [ \r\t\tempate:=(jugadorFueraTurno menuTablas: jugadorFueraTurnoNum)."Pregunto al otro jugador si quiere aceptar las tablas"\r\t(empate) ifTrue: [ganador := \'EMPATE\'.\r\t\t\tUIManager default alert:(\'La partida se resolvio en tablas\') title: \'FIN DEL JUEGO\'.\r\t\t\t]."Si acepta indico que termino el juego"\r\t(empate) ifFalse: [posiblesTablas:= false.\r\t\t\tUIManager default alert: \'El adversario rechazo la propuesta de tablas elija una opcion\' title: \'Jugador \',turnoJugadorNum asString.\r\t\t\ttablasRechazadas:=false.\r\t\t\tjugadorEnTurno setTablas: false."seteo nuevamente en false la variable tablas del jugador que propuso (Se modificaba en menuOpcionesJugador a true cuando ofrecia tablas)"\r\t\t\t\t]."Si el otro jugador lo rechaza le indico al jugador que rechazaron la propuesta y seteo tablasrechazadas en true para que no se produzca un cambio de turno y que el jugador que propuso no pierda su turno y elija una opcion nuevamente"\r\t\t\t ].\r\t\t\r"UN JUGADOR TERMINA SU TURNO Y PASA AL SIGUIENTE JUGADOR"\t\t\r(tablasRechazadas & (ganador isNil)) ifTrue: [  "Si se rechazaron tablas esto hace que el jugador que las propuso no pierda su turno"\r\tnoSaltar :=true.\r\t(turnoJugadorNum=1)ifTrue: [jugadorFueraTurnoNum :=turnoJugadorNum.\r\t\t turnoJugadorNum :=2. \r\t\t noSaltar :=false. "Lo utilizo para indicar que ya se hizo un cambio"\r\t\t]."Intercambio los turnos"\r\t\t(turnoJugadorNum=2 & noSaltar)ifTrue: [ jugadorFueraTurnoNum :=turnoJugadorNum.\r\t\tturnoJugadorNum:=1.\r\t\t ].\r\tjugadorEnTurno:= (colJugadores at: turnoJugadorNum )."jugador1: piezas blancas jugador2 piezas negras."\r\tjugadorFueraTurno :=(colJugadores at: jugadorFueraTurnoNum ).\r\t].\r\t\r"UN JUGADOR SE RINDE (2)"\t\r(rendicion)ifTrue: [ ganador:= (jugadorEnTurno asString).\r\tUIManager default alert:(\'Ganador: Jugador\',turnoJugadorNum asString) title: \'UN JUGADOR SE A RENDIDO\'.].\r\r"SUMO MOVIMIENTO Y VERIFICO SI SE EXEDIO PARA TERMINAR EL JUEGO EN TABLAS"\rcantMovimientos := cantMovimientos +1.\r(cantMovimientos >= movimientosMax )ifTrue: [ ganador := \'EMPATE\'.\r\t\t\tUIManager default alert:(\'La partida se resolvio en tablas por que se realizo la cantidad de movimientos preestablecida por los jugadores\') title: \'FIN DEL JUEGO\'.\r\t\t\t].\r\t ].\r"FIN DEL JUEGO"\r\ttablero delete."si sale de while significa que termino la partida por lo tanto borro el tablero"\r].\r(menu=2)ifTrue: [\r\ttablero delete. "Si elije \'SALIR\' borro el Morph tablero (como las piezas \'estan a‚àö¬±adidas\' a este tambien desaparecen"\r\t ].',			#stamp : 'Manu 11/11/2020 13:56',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}