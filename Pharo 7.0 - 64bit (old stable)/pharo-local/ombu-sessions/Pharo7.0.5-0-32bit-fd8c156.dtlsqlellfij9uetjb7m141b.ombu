OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2021-02-17T11:34:24.750847-03:00' ],		#prior : OmReference [ 'Pharo7.0.5-0-32bit-fd8c156.67wkczu3kib4mwldh64h12yux', '1' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Pieza			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero',			#stamp : 'ManuelLatorre 8/2/2019 14:07',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Pieza			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r^self subclassResponsibility.',			#stamp : 'Manu 2/17/2021 11:34',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2021-02-17T11:38:16.093847-03:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ "si llego al final no puede comer"\r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[ "NO uso verificarEscaqueEnFila por que cuenta que puede comer para adelante"\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por delante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t\t\t\t\t\t\r\t\t\t\tprimerMovimiento := false."CORRECCION"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\r"primerMovimiento := false.Como si o si se va a realizar el movimiento lo seteo en false  MAL"\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/17/2020 12:08',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Peon			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|escaqueMov filaEscaqueMueveUnaPosi filaEscaqueMueveDosPosi haceMov comeFila comeColumnaIzq comeColumnaDer piezaAComer signo|\rhaceMov:= false.\rcolPosiblesMovimientos reset.\rsigno:=1.\r(color=(Color black))ifTrue: [ signo:=-1 ]."Para saber si se mueve para arriba o para abajo"\r\r\tfilaEscaqueMueveUnaPosi := filaPieza+signo.\r\tfilaEscaqueMueveDosPosi := filaPieza+(2*signo).\r\t(((filaPieza<8) & (signo=1))|((filaPieza>1)& (signo=(-1)))) ifTrue: [ haceMov:=true ]."Si llegue al final no puedo mover"\r\r\t\r\t(columnaPieza =1)ifTrue: [ "Si estoy en el borde no puedo comer para ese lado"\r\t\tcomeFila:= filaPieza +signo.\r\t\tcomeColumnaDer := columnaPieza +1.\r\t\tcomeColumnaIzq :=nil.\r\t\t ].\r\t(columnaPieza =8)ifTrue: [ \r\t\tcomeFila :=filaPieza+signo.\r\t\tcomeColumnaIzq:= columnaPieza -1.\r\t\tcomeColumnaDer :=nil.\r\t\t ].\r\t\r\t((columnaPieza>1) & (columnaPieza<8))ifTrue:[ "Lugares para donde puede comer"\r\tcomeFila:= filaPieza +signo.\r\tcomeColumnaIzq := columnaPieza-1.\r\tcomeColumnaDer:= columnaPieza +1.\r\t].\r\t(((filaPieza =8) &(signo=1)) | ((filaPieza=1) & (signo=(-1))))ifTrue: [ "si llego al final no puede comer"\r\t\tcomeColumnaDer:=nil.\r\t\tcomeColumnaIzq:=nil.\r\t\t ].\r\r(haceMov)ifTrue:[ "NO uso verificarEscaqueEnFila por que cuenta que puede comer para adelante"\r\t\t\tescaqueMov := unTablero escaqueAt: (filaEscaqueMueveUnaPosi) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil:["verifico que el posible nuevo escaque este vacio"\r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque una posicion por delante de a donde esta ubicada la pieza"\r\t\t\t].\r\t((primerMovimiento) & (colPosiblesMovimientos isNotEmpty))ifTrue: [ "Si es el primer movimiento puede avanzar dos posiciones tambien. Verifico que la coleccion no este vacia ya que significa que no se pudo hacer un movimiento de un solo escaque porque hay una pieza contraria bloqueando"\r\t\t\tescaqueMov:= unTablero escaqueAt: (filaEscaqueMueveDosPosi ) at: columnaPieza.\r\t\t\t(escaqueMov getPiezaEscaque)ifNil: [ \r\t\t\t\tcolPosiblesMovimientos add: escaqueMov. "A√±ade a mi coleccion el escaque 2 posiciones por \t\t\t\tdelante a donde esta ubicada la pieza"\r\t\t\t\t\t\t\t\t\r\t\t\t\tprimerMovimiento := false."CORRECCION ERROR DE ABAJO"\r\t\t\t].\r\t].\r\r].\t\r\t\r\t\r\t\t(comeColumnaDer )ifNotNil: [ "Verifico si puede comer escaque de la diagonal derecha"\r\t\t\t piezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaDer)getPiezaEscaque).\r\t\t\t (piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaDer enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\t\r\t\t(comeColumnaIzq)ifNotNil: [ "verifico si puede comer escaque de la diagonal izquierda"\r\t\t\tpiezaAComer := ((unTablero escaqueAt: comeFila at: comeColumnaIzq)getPiezaEscaque).\r\t\t\t(piezaAComer)ifNotNil: [ \r\t\t\t\t\tself verificarEscaqueEnFila: comeFila enColumna: comeColumnaIzq enTablero: unTablero.\r\t\t\t ].\r\t\t].\r\r^colPosiblesMovimientos.',			#stamp : 'Manu 2/17/2021 11:38',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}OmEntry {	#tags : {		#author : 'Manu',		#time : DateAndTime [ '2021-02-17T11:38:30.466847-03:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Rey			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|listaMovimientos|\rcolPosiblesMovimientos reset.\rlistaMovimientos := self movimientoUnCasillero.\r\r"arriba y abajo los meti en arrays verifico que esten en los limites antes de probar los escaques"\rlistaMovimientos do:[:movimiento| \r\t(((movimiento at:1)>0) & ((movimiento at:1)<9) & ((movimiento at:2)>0) & ((movimiento at:2)<9))\tifTrue:[\r\t\t(((movimiento at:1)=filaPieza) & ((movimiento at:2)=columnaPieza))ifFalse: [ \r\t\t\tself verificarEscaqueEnFila: (movimiento at:1) enColumna: (movimiento at:2)  enTablero: \t\t\tunTablero.\r\t\t].\r\t].\r].\r^colPosiblesMovimientos.',			#stamp : 'Manu 11/11/2020 13:41',			#package : #'POO Tp obligatorio libre Ajedrez'		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #Rey			},			#name : #'posiblesMov:',			#protocol : #'as yet unclassified',			#sourceCode : 'posiblesMov: unTablero\r|listaMovimientos|\rcolPosiblesMovimientos reset.\rlistaMovimientos := self movimientoUnCasillero.\r\r"arriba y abajo los meti en arrays verifico que esten en los limites antes de probar los escaques"\rlistaMovimientos do:[:movimiento| \r\t(((movimiento at:1)>0) & ((movimiento at:1)<9) & ((movimiento at:2)>0) & ((movimiento at:2)<9))\tifTrue:[\r\t\t(((movimiento at:1)=filaPieza) & ((movimiento at:2)=columnaPieza))ifFalse: [ \r\t\t\tself verificarEscaqueEnFila: (movimiento at:1) enColumna: (movimiento at:2)  enTablero: unTablero.\r\t\t].\r\t].\r].\r^colPosiblesMovimientos.',			#stamp : 'Manu 2/17/2021 11:38',			#package : #'POO Tp obligatorio libre Ajedrez'		}	}}